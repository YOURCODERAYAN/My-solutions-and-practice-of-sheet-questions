// we are starting of the concept of BINARY SEARCH 
// Q--> 1 .. SUPPOSE YOU ARE GIVEN AN ARRAY OF SORTED ELEMENTS IN IT 
//LIKE arr[]={3,4,6,7,9,12,16,17} and you have a target variable of target== 6 
// so you have to found it 
// so to solve this problem we are using binary search 

// 1st Method is iterative method 

/*#include<bits/stdc++.h>
using namespace std;

int search(vector<int>&nums,int target){
    int n=nums.size();
    // we have to take two pointers 
    int low=0,high=n-1;
    // apply the algorithm
    while(low<=high){
        int mid=(low+high)/2;

        if(nums[mid]==target) return mid;
        else if(target > nums[mid]){
            low=mid+1;
        }
        else{
            high=mid-1;
        }
    }
    return -1;// dummy statement
}
int main(){
    vector<int> nums={3,4,6,7,9,12,16,17};
    int target=6;
    int n=8;
    int inde=search(nums,target);
    if(inde==-1) cout << "no target is present ";
    else{
        cout << "the target is " << inde << endl;
    }
    return 0;
}*/

// THE SAME PROBLEM BUT IF YOU USE RECUESIVE APPROACH 

/*#include<bits/stdc++.h>
using namespace std;

int binary(vector<int>&nums,int low,int high,int target){
    int n=nums.size();
    if (low>high) return -1;

    int mid=(low+high)/2;

    if(nums[mid]==target) return mid;
    else if(target > nums[mid])
        return binary(nums,mid+1,high,target);
        return binary(nums,low,mid-1,target);
}

    int search1(vector<int>&nums,int target){
        return binary(nums,0,nums.size()-1,target);

}
int main(){
    vector<int> nums={3,4,6,7,9,12,16,17};
    int n=8;
    int target=6;
    int ind=search1(nums,target);
    if(ind==-1) cout << " there is not present";
    else{
        cout << "the answer is " << ind << endl;
    }
    return 0;
}*/


// coming to the main questions part 
//1. Binary Search to find X in sorted array 

/*#include<bits/stdc++.h>
using namespace std;

int binary(vector<int>&nums,int target){
    int n=nums.size();
    int low=0,high=n-1;

    while(low <= high){
        int mid=(low+high)/2;

        if(nums[mid]==target) return mid;
        if(target > nums[mid]){
            low=mid+1;
        }
        else{
            high=mid-1;
        }
    }
    return -1;
}
int main(){
    vector<int> nums={3,4,6,7,9,12,16,17};
    int n=8;
    int target=8;
    int ans=binary(nums,target);
    if(ans==-1) cout << "the answer is not present ";
    else{
        cout << "the answer is " << ans << endl;
    }
    return 0;
}*/


//2. Implement Lower Bound ..nums[mid] >= x //
// x stands for target

/*#include<bits/stdc++.h>
using namespace std;

int lower(vector<int>&nums ,int target){

    int n=nums.size();
    int low=0,high=n-1;
    int ans=-1;

    while(low <= high){
        int mid=(low+high)/2;

        if(nums[mid] >= target){
            ans=mid;
            high=mid-1;
        }
        else{
            low=mid+1;
        }
    }
    return ans;
}
int main(){
    vector<int> nums={3,5,8,15,19};
    int n=5;
    int target=9;
    int ans=lower(nums,target);
    cout << "the answer " << ans << endl;
    return 0;
}*/

//3.. Implement Upper Bound..

/*#include<bits/stdc++.h>
using namespace std;

int upper(vector<int>&nums,int target){
    int n=nums.size();

    int low=0,high=n-1;
    int ans=-1;

    while(low <= high){
        int mid=(low+high) / 2;

        if(nums[mid] > target){
            ans=mid;
            high=mid-1;
        }
        else{
            low=mid+1;
        }
    }
    return ans;
}
int main(){
    vector<int> nums={3,5,8,15,19};
    int n=5;
    int target=9;
    int val=upper(nums,target);
    cout << "the val is " << val << endl;
    return 0;
}*/

//4.. Search insert position 

// this is a classical problem of implementation of lower Bound 

/*#include<bits/stdc++.h>
using namespace std;

int insert(vector<int>&nums,int x){
    int n=nums.size();

    int low=0,high=n-1;
    int ans=-1;
    // application of lower Bound algo

    while(low<=high){
        int mid=(low+high)/2;
        if(nums[mid] >= x){
            ans=mid;
            high=mid-1;
        }
        else{
            low=mid+1;
        }
    }
    return ans;
}
int main(){
    vector<int> nums={1,2,4,7};
    int n4;
    int x=3;
    int ans=insert(nums,x);
    cout << "the insertable index is" << ans << endl;
    return 0;
}*/

//5.. Floor and Ceil in Sorted Array

// floor == arr[mid] <= x.. juust remeber this .
// ceil == arr[mid] >= x... just remember this .

// we have to return it in a pair 
// ceil is the same algorithm like lowerBound 
// but there  is no algo for taking out floor so 
// we can implement binary search but slightly modified way
// to take out the result 

/*#include<bits/stdc++.h>
using namespace std;
// this is the program of floor
int floor(int arr[],int x,int n){
   

    int low=0,high=n-1;
    int ans=-1;

    while(low <= high){
        int mid=(low+high)/2;
        if(arr[mid] <= x){
            ans=arr[mid];
            low=mid+1;
        }
        else{
            high=mid-1;
        }
    }
    return ans;
}
// this is the program  of ceil
int ceil(int arr[],int x,int n){

    int low=0,high=n-1;
    int ans=-1;
    while(low<=high){
        int mid=(low+high)/2;
        if(arr[mid] >= x){
            ans=arr[mid];
            high=mid-1;
        }
        else{
            low=mid+1;
        }
    }
    return ans;
}
// from this portion we are returing the pair value of floor and ceil
pair<int,int> total(int arr[], int n,int x){
    int f=floor(arr,x,n);
    int c=ceil(arr,x,n);
    return make_pair(f,c);
}
int main(){
    int arr[]={3,4,4,7,8,10};
    int n=6;
    int x=5;
    pair<int,int> ans=total(arr,n,x);
    cout << " " << ans.first << " " << ans.second << endl;
    }*/


// 6. Find the first and the last occurance of the given 
      // number in a sorted array ...
    
// this problem can be solve in two ways 
// Approach 1 :- using lower bound and upper bound functionalities
//Approach 2:- using binary search algorithm 

// first Approach 
/*#include<bits/stdc++.h>
using namespace std;

// first lower bound 
int lower(vector<int>&nums,int target){

    int n=nums.size();
    int low=0,high=n-1;
    int ans=-1;
    while(low<=high){
        int mid=(low+high)/2;
        if(nums[mid] >= target){
            ans=mid;
            high=mid-1;
        }
        else{
            low=mid+1;
        }
    }
    return ans;
}

// next implement upperbound 

int upper(vector<int>&nums,int target){
    int n=nums.size();

    int low=0,high=n-1;
    int ans=-1;
    while(low<=high){
        int mid=(low+high)/2;
        if(nums[mid]> target){
            ans=mid;
            high=mid-1;
        }
        else{
            low=mid+1;
        }
    }
    return ans;
}
//
vector<int> occurance(vector<int>&nums,int target){
    int n=nums.size();
    int lb=lower(nums,target);
    int ub=upper(nums,target);
    // edge cases we have to look up for
    // if the given target is not in the array 
    // and suppose if if the target is out of range so 
    // the pointer will point the hypothetical array
    // in these cases we will return -1
    
    if(lb==n||nums[lb]!=target) return {-1,-1};
    else{
        // we have to return the lower bound ans 
        // and upper bound but substract it with -1 that will
        //return the last occurance index
         return {lb,ub-1};
    }

}
int main(){
    vector<int> nums={5,7,7,8,8,10};
    int n=6;
    int target=8;
    vector<int> ans=occurance(nums,target);
    cout << "the anss is ";
    for(auto it:ans){
        cout << it << " ";
    }
    return 0;

}*/

// second approach 
// using binary search algorithm 
//now code for the first_occuurance 
/*#include<bits/stdc++.h>
using namespace std;

int first_occurance(vector<int>&nums, int target){
    int n=nums.size();
    int low=0,high=n-1;
    int first=-1;
    while(low<=high){
        int mid=(low+high)/2;
        if(nums[mid]==target){
            first=mid;
            high=mid-1;
        }
        else if(nums[mid] < target){
            low=mid+1;
        }
        else{
            high=mid-1;
        }
    }
    return first;
}

// now code for the last occurance 

int last_occurance(vector<int>&nums,int target){
    int n=nums.size();
    int low=0,high=n-1;
    int last=-1;
    while(low<=high){
        int mid=(low+high)/2;
        if(nums[mid]==target){
            last=mid;
            low=mid+1;
        }
        else if(nums[mid] < target){
            low=mid+1;
        }
        else{
            high=mid-1;
        }
    }
    return last;
}

vector<int> combined(vector<int>&nums,int target){
    int n=nums.size();
    int first=first_occurance(nums,target);
    if(first==-1) return {-1,-1};
    int last=last_occurance(nums,target);
    return {first,last};
}

    int main(){
        vector<int> nums={5,7,7,8,8,10};
        int target=8;
        vector<int> ans=combined(nums,target);
        cout << "this approach ans will be " ;
        for(auto it:ans){
            cout << it << " ";
        }

    }*/


//7. count occurance of the number in a sorted array 
// with duplicates

// this is same as like previous code 
// we may can use binary search using first and last 
//occurance in the array which help  to found the 
// count of digits 
// just at last use this concept 
//TOTAL NO OF OCCURANCES = (LAST_OCCURANCE-FIRST_OCCURANCE+1)

/*#include<bits/stdc++.h>
using namespace std;

int first_occurance(vector<int>&nums,int target){
    int n=nums.size();
    int low=0,high=n-1;
    int first=-1;
    while(low<=high){
        int mid=(low+high)/2;
        if(nums[mid]==target){
        first=mid;
        high=mid-1;
        }

        else if(nums[mid] < target){
            low=mid+1;
        }
        else{
            high=mid-1;
        }
    }
    return first;
}

int last_occurance(vector<int>&nums,int target){
    int n=nums.size();
    int low=0,high=n-1;
    int last=-1;

    while(low<=high){
        int mid=(low+high)/2;
        if(nums[mid]==target){
        last=mid;
        low=mid+1;
        }

        else if (nums[mid] < target){
            low=mid+1;
        }
        else{
            high=mid-1;
        }
    }
    return last;
}
pair<int,int> combined1(vector<int>&nums,int target){
    int n=nums.size();
    int first=first_occurance(nums,target);
    if(first==-1) return {-1,-1};
    int last=last_occurance(nums,target);
    return {first,last};
}

int  count(vector<int>&nums,int target){
    int n=nums.size();
    pair<int,int> ans=combined1(nums,target);
    if(ans.first==-1) return 0;
    else{
        return (ans.second-ans.first+1);
    }
}
int main(){
    vector<int> nums={5,7,7,8,8,8,10};
    int target=8;
    int ans=count(nums,target);
    cout << "the count is " << ans << " ";
}*/

//8.Search in rotated sorted array I
// note that this type of array which we have to work
//contains all unique elements
/*#include<bits/stdc++.h>
using namespace std;

int search1(vector<int>&nums,int x){
    int n=nums.size();
    int low=0,high=n-1;

    while(low<=high){
        int mid=(low+high)/2;

        if(nums[mid]==x) return mid;

        if(nums[low] <= nums[mid])
        if(nums[low] <= x && x <=nums[mid])
            high=mid-1;
        else
            low=mid+1;
        
        else{
            if(nums[mid] <= x && x<=nums[high])
                low=mid+1;
            else{
                high=mid-1;
            }
        }
    } 
    return -1;  
}
int main(){
    vector<int> nums={4,5,6,7,0,1,2};
    int x=0;
    int ans=search1(nums,x);
    cout << "the answer is " << ans << " " << endl;
}*/

//9. Search in Rotated sorted array II
//In this type of problem the array  may contain 
// duplicate elemnts but in the type 1 the array contain 
// all unique elents 
// so there will be a edge case which will be 
// arr[low]=arr[mid]=arr[high]
// so in that case we have to move pointer 
// low=low+1 && high=high-1 and break;

/*#include<bits/stdc++.h>
using namespace std;

bool search2(vector<int> &nums,int target){
    int n=nums.size();
    int low=0,high=n-1;

    while(low<=high){
        int mid=(low+high)/2;
        if(nums[mid]==target) return true;

    // now to be carefull about the edge case 
    if(nums[low]==nums[mid] && nums[mid]==nums[high]){
        low=low+1;
        high=high-1;
        continue;
    }

    if(nums[low] <= nums[mid]){
    if(nums[low] <= target && target <=nums[mid]){
        high=mid-1;
    }
    else {  
        low=mid+1;
    }
    }
    
    else{
        if(nums[mid] <= target && target <= nums[high]){
            low=mid+1;
        }
        else{
            high=mid-1;
        }
    }
}
return false;
}

int main(){
    vector<int> nums={2,5,6,0,0,1,2};
    int target=0;
    bool ans=search2(nums,target);
    if(!ans)
        cout << "the answer is  not present";
    else
        cout << "the answer is present";
    return 0;
}*/

//10.Find minimum in the rotated sorted array

/*#include<bits/stdc++.h>
using namespace std;

int minimum(vector<int>&nums){
    int n=nums.size();
    int low=0,high=n-1;
    int ans=INT_MAX;


    while(low<=high){
        int mid=(low+high)/2;
// if the left part is sorted we have to pick min 
//and trim down that part
    if(nums[low] <= nums[mid]){
        ans=min(ans,nums[low]);
        low=mid+1;
    }
// same but in case of right part 
// we have to trim down the right part 
    else{ // in this we are checking 
            // (nums[mid] <= nums[high])
        ans=min(ans,nums[mid]);
        high=mid-1;
    }
}
return ans; // at the end we are returning 
//the updated ans
}

int main(){
    vector<int> nums={3,4,5,1,2};
    int n=5;
    int ans=minimum(nums);
    cout << "the minimum element is " << ans << " " << endl;

}*/

//11. Find out how many times the array is rotated 

//note to solve this problem we can usen previous approach 
// just we have to eleborate ans part and add extra variable index
// to found the rotating times 
// main point is the index of the minimum element in the array
// is the ans that how many many times the array is rotated 

/*#include<bits/stdc++.h>
using namespace std;

int howmany(vector<int>&nums){
    int n=nums.size();
    int low=0,high=n-1;
    int ans=INT_MAX;
    int index=-1;// now in this program we have to take index 
    // which we have to return at the end to found the answer

    while(low<=high){
        int mid=(low+high)/2;

        if(nums[low] <= nums[mid]){
            if(nums[low] < ans){
                index=low;
                ans=nums[low];
            }
            low=mid+1;
        }

        else{
            if(nums[mid] < ans){
                index=mid;
                ans=nums[mid];
            }
            high=mid-1;
        }
    }
    return index;
}

int main(){
    vector<int> nums={3,4,5,1,2};
    int ans=howmany(nums);
    cout << "the rotating times" << ans << " " << endl; 
}*/

//12.Single element in a sorted array

//  we are implementing concept of (even odd) or (odd even)
//  and we have to check if the mid is not eual to the previous and the next element 


/*#include<bits/stdc++.h>
using namespace std;

int single(vector<int>&nums,int n){

    if(n==1) return nums[0];// if there is only one elemnt in the array
                            // then we are returing the element itself 

    // now to trim down a couple of coditions 
if(nums[0]!=nums[1]) return nums[0];
if(nums[n-1]!=nums[n-2])return nums[n-1];

    int low=1,high=n-2;

while(low<=high){
    int mid=(low+high)/2;
if(nums[mid]!=nums[mid-1] && nums[mid]!=nums[mid+1])
        return nums[mid];

// now if condition is (even,odd) 
    if((mid%2==1 && nums[mid]==nums[mid-1]) or (mid%2==0 && nums[mid]==nums[mid+1])){
        low=mid+1;
    }
    else {
        high=mid-1;
    }
}
return -1;
}

int main(){
    vector<int> nums={1,1,2,3,3,4,4,8,8};
    int n=9;
    int ans=single(nums,n);
    cout << "the single element is " << ans << " " << endl;

}*/

//13.Find the Peak element in the array

#include<bits/stdc++.h>
using namespace std;

int peak(vector<int>&nums,int n){
    if(n==1) return nums[0];
// if the peak elemnt is on the at first position or 
// at last position of the array so we are manually searching 
// it will reduce the lots of condition
    if(nums[0] > nums[1]) return nums[0];
    if(nums[n-1] > nums[n-2]) return nums[n-1];
    int low=1,high=n-2;

    while(low<=high){
        int mid=(low+high)/2;
    
    if(nums[mid] > nums[mid-1] && nums[mid] > nums[mid+1]){
        return nums[mid];
    }
    
    else if(nums[mid] > nums[mid-1]){
        low=mid+1;
     }             // therefore we can say that the element is in the 
                    // the incresing curve shift low=mid+1 means trim down 
                    // the left elment is on the right
    else if(nums[mid]> nums[mid+1]){
        high=mid-1;
    }
        // now if there is for there are multiple peaks in any array
        // or the array is like {1,5,1,2,1} for that if two abobe conditions
        // fail then go to any direction left or right we can find any of the peak
    /*else{
        low=mid+1;
    }*/
    }
    return -1;
}
int main(){
    vector<int> nums={1,2,1,3,5,6,4};
    int n=7;
    int ans=peak(nums,n);
    cout << "the peak is " << ans << " " << endl;
}




